name: Post Deployment Tests

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment'
        required: true
        type: string
      project_name:
        description: 'Project Name'
        required: true
        type: string
      company_list:                       
        description: 'Company list'
        required: false
        type: string
        default: '["dunder_mifflin","ollie_pets_2"]'

permissions:
  id-token: write
  contents: read

jobs:
  stabilize:
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.ROLE_TO_ASSUME }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Get ECS Cluster Name from SSM
        id: get_cluster_name
        run: |
          CLUSTER_NAME=$(aws ssm get-parameter --name "/common-infrastructure/cabernet_ai_ecs_cluster_id" --query "Parameter.Value" --output text)
          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV

      - name: Wait for ECS Service to Stabilize
        id: wait
        run: |
          set -Eeuo pipefail
          SERVICE_NAME=${{ inputs.project_name }}-service
          echo "Waiting for ECS service $SERVICE_NAME to stabilize..."
          aws ecs wait services-stable --cluster "${{ env.CLUSTER_NAME }}" --services "$SERVICE_NAME"

  post-deployment-tests:
    needs: 
      - stabilize
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Newman
        run: npm install -g newman

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.ROLE_TO_ASSUME }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Retrieve Cognito Token
        run: |
          set -Eeuo pipefail
          TOKEN=$(./tests/getToken.sh)
          echo "TOKEN=$TOKEN" >> $GITHUB_ENV

      - name: Run Postman tests
        run: |
          set -Eeuo pipefail
          newman run "tests/postman/${{ inputs.project_name }}.postman_collection.json" \
            -e "tests/postman/${{ inputs.environment }}.postman_environment.json" \
            --env-var "bearer_token=${{ env.TOKEN }}" \
            --bail

      - name: Get Commit and PR Info
        id: context_info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const isPR = context.eventName === "pull_request";
            const commit = await github.rest.repos.getCommit({
              owner: context.repo.owner, repo: context.repo.repo, ref: context.sha,
            });
            const authorLogin = commit.data.author?.login;
            const authorName  = commit.data.commit?.author?.name;
            const actor = context.actor || authorLogin || authorName || "unknown";
            core.setOutput("commit_sha", context.sha);
            core.setOutput("repository", `${context.repo.owner}/${context.repo.repo}`);
            core.setOutput("actor", actor);
            core.setOutput("branch_ref", context.ref);
            core.setOutput("pr_number", isPR ? String(context.payload.pull_request.number) : "");

  trigger-smoke-test:
    needs: 
      - post-deployment-tests
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-latest
    env:
      STATE_MACHINE_ARN: arn:aws:states:${{ vars.AWS_REGION }}:${{ vars.AWS_ACCOUNT_ID }}:stateMachine:VDRSmokeTestStateMachine
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.ROLE_TO_ASSUME }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: AWS sanity check
        run: |
          set -Eeuo pipefail
          aws --version
          aws sts get-caller-identity
          aws stepfunctions describe-state-machine --state-machine-arn "$STATE_MACHINE_ARN" >/dev/null

      - name: Generate GitHub context JSON
        id: github_context
        run: |
          set -Eeuo pipefail
          REPO="${{ steps.context_info.outputs.repository }}"
          SHA="${{ steps.context_info.outputs.commit_sha }}"
          ACTOR="${{ steps.context_info.outputs.actor }}"
          [ -z "$REPO" ] && REPO="${{ github.repository }}"
          [ -z "$SHA" ] && SHA="${{ github.sha }}"
          [ -z "$ACTOR" ] && ACTOR="${{ github.actor }}"
          ACTOR=$(echo "$ACTOR" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]/-/g')
          PR_NUMBER="${{ steps.context_info.outputs.pr_number }}"
          SHORT_SHA=$(echo "$SHA" | cut -c1-7)

          GITHUB_CONTEXT_JSON=$(jq -n \
            --arg repo "$REPO" \
            --arg ref "${{ github.ref }}" \
            --arg sha "$SHA" \
            --arg short_sha "$SHORT_SHA" \
            --arg actor "$ACTOR" \
            --arg branch_ref "${{ steps.context_info.outputs.branch_ref }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg run_number "${{ github.run_number }}" \
            --arg workflow "${{ github.workflow }}" \
            --arg job "${{ github.job }}" \
            --arg event_name "${{ github.event_name }}" \
            --arg event_ref "${{ github.event.ref }}" \
            --arg event_head_ref "${{ github.event.head_ref }}" \
            --arg event_base_ref "${{ github.event.base_ref }}" \
            --arg event_pull_request_number "$PR_NUMBER" \
            '{
              repository: $repo,
              ref: $ref,
              branch_ref: $branch_ref,
              sha: $sha,
              short_sha: $short_sha,
              actor: $actor,
              run_id: $run_id,
              run_number: $run_number,
              workflow: $workflow,
              job: $job,
              event_name: $event_name,
              event_ref: $event_ref,
              event_head_ref: $event_head_ref,
              event_base_ref: $event_base_ref,
              event_pull_request_number: $event_pull_request_number
            }')
          echo "github_context_json<<EOF" >> $GITHUB_OUTPUT
          echo "$GITHUB_CONTEXT_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate execution name
        id: execution_name
        run: |
          REPO_NAME=$(echo "${{ inputs.repository }}" | sed 's/.*\///')
          [ -z "$REPO_NAME" ] && REPO_NAME=$(echo "${{ github.repository }}" | sed 's/.*\///')
          SHORT_SHA=$(echo "${{ inputs.commit_sha }}" | cut -c1-7)
          [ -z "$SHORT_SHA" ] && SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          ACTOR="${{ inputs.actor }}"
          [ -z "$ACTOR" ] && ACTOR="${{ github.actor }}"
          EXEC_NAME="smoketest-$REPO_NAME-$SHORT_SHA-$ACTOR"
          MAX_LENGTH=$((256 - 9))
          if [ ${#EXEC_NAME} -gt $MAX_LENGTH ]; then
            EXEC_NAME="${EXEC_NAME:0:$MAX_LENGTH}"
          fi
          UUID=$(cat /proc/sys/kernel/random/uuid | tr -d '-' | cut -c1-8)
          EXEC_NAME="$EXEC_NAME-$UUID"
          echo "execution_name=$EXEC_NAME" >> $GITHUB_OUTPUT

      - name: Prepare Step Function input
        id: prepare_input
        run: |
          set -Eeuo pipefail
          RAW_COMPANY='${{ inputs.company_list }}'
          if [ -z "$RAW_COMPANY" ]; then RAW_COMPANY="[]"; fi
          echo "$RAW_COMPANY" | jq -e . >/dev/null
          COMPANY_COMPACT=$(echo "$RAW_COMPANY" | jq -c .)

          GITHUB_CONTEXT='${{ steps.github_context.outputs.github_context_json }}'
          echo "$GITHUB_CONTEXT" | jq -e . >/dev/null

          INPUT_JSON=$(jq -n \
            --arg environment "${{ inputs.environment }}" \
            --argjson company_list "$COMPANY_COMPACT" \
            --argjson github_context "$GITHUB_CONTEXT" \
            '{environment: $environment, company_list: $company_list, github_context: $github_context}' )
          echo "input_json<<EOF" >> $GITHUB_OUTPUT
          echo "$INPUT_JSON" | jq -c . >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Trigger Step Function
        id: stepfn
        run: |
          set -e
          echo "Triggering Step Function with execution name: ${{ steps.execution_name.outputs.execution_name }}"
          echo "Input: ${{ steps.prepare_input.outputs.input_json }}"
          EXECUTION_ARN=$(aws stepfunctions start-execution \
            --state-machine-arn "arn:aws:states:${{ vars.AWS_REGION }}:${{ vars.AWS_ACCOUNT_ID }}:stateMachine:VDRSmokeTestStateMachine" \
            --name "${{ steps.execution_name.outputs.execution_name }}" \
            --input '${{ steps.prepare_input.outputs.input_json }}' \
            --query 'executionArn' \
            --output text)
          echo "execution_arn<<EOF" >> $GITHUB_OUTPUT
          echo "$EXECUTION_ARN" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "execution_name=${{ steps.execution_name.outputs.execution_name }}" >> $GITHUB_OUTPUT
          echo "Step Function execution started:"
          echo "  Execution ARN: $EXECUTION_ARN"
          echo "  Execution Name: ${{ steps.execution_name.outputs.execution_name }}"

      - name: Display execution details
        if: always()
        run: |
          echo "## Step Function Execution Details ###"
          echo "- **Execution Name**: ${{ steps.execution_name.outputs.execution_name }}"
          echo "- **State Machine ARN**: arn:aws:states:${{ vars.AWS_REGION }}:${{ vars.AWS_ACCOUNT_ID }}:stateMachine:VDRSmokeTestStateMachine"
          if [ "${{ steps.stepfn.outputs.execution_arn }}" != "" ]; then
            echo "- **Execution ARN**: ${{ steps.stepfn.outputs.execution_arn }}"
            echo "- **Status**: Started successfully"
          else
            echo "- **Status**: Failed to start"
          fi 

